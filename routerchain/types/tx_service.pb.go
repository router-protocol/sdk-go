// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/tx_service.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetTxRequest struct {
	// Transaction hash in hex without 0x prefix (Cosmos-like).
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *GetTxRequest) Reset()         { *m = GetTxRequest{} }
func (m *GetTxRequest) String() string { return proto.CompactTextString(m) }
func (*GetTxRequest) ProtoMessage()    {}
func (*GetTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{0}
}
func (m *GetTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxRequest.Merge(m, src)
}
func (m *GetTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxRequest proto.InternalMessageInfo

func (m *GetTxRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type GetTxResponse struct {
	// Hex-encoded Tendermint transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// The block height
	Height int64 `protobuf:"zigzag64,2,opt,name=height,proto3" json:"height,omitempty"`
	// Tx index in the block
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	// Namespace for the resp code
	Codespace string `protobuf:"bytes,4,opt,name=codespace,proto3" json:"codespace,omitempty"`
	// Response code
	Code uint32 `protobuf:"varint,5,opt,name=code,proto3" json:"code,omitempty"`
	// Result bytes, if any
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// The output of the application's logger (raw string). May be
	// non-deterministic.
	RawLog string `protobuf:"bytes,7,opt,name=raw_log,json=rawLog,proto3" json:"raw_log,omitempty"`
	// Time of the previous block.
	Timestamp string `protobuf:"bytes,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *GetTxResponse) Reset()         { *m = GetTxResponse{} }
func (m *GetTxResponse) String() string { return proto.CompactTextString(m) }
func (*GetTxResponse) ProtoMessage()    {}
func (*GetTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{1}
}
func (m *GetTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxResponse.Merge(m, src)
}
func (m *GetTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxResponse proto.InternalMessageInfo

func (m *GetTxResponse) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *GetTxResponse) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *GetTxResponse) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetTxResponse) GetCodespace() string {
	if m != nil {
		return m.Codespace
	}
	return ""
}

func (m *GetTxResponse) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetTxResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetTxResponse) GetRawLog() string {
	if m != nil {
		return m.RawLog
	}
	return ""
}

func (m *GetTxResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

type PrepareTxRequest struct {
	// Specify chainID for the target tx
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Specify Ethereum address of a signer
	SignerAddress string `protobuf:"bytes,2,opt,name=signer_address,json=signerAddress,proto3" json:"signer_address,omitempty"`
	// Account sequence number (nonce) of signer
	Sequence uint64 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Textual memo information to attach with tx
	Memo string `protobuf:"bytes,4,opt,name=memo,proto3" json:"memo,omitempty"`
	// Block height until which the transaction is valid.
	TimeoutHeight uint64 `protobuf:"varint,5,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
	// Transaction fee details.
	Fee *CosmosTxFee `protobuf:"bytes,6,opt,name=fee,proto3" json:"fee,omitempty"`
	// List of Cosmos proto3-encoded Msgs to include in a single tx
	Msgs [][]byte `protobuf:"bytes,7,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *PrepareTxRequest) Reset()         { *m = PrepareTxRequest{} }
func (m *PrepareTxRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareTxRequest) ProtoMessage()    {}
func (*PrepareTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{2}
}
func (m *PrepareTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareTxRequest.Merge(m, src)
}
func (m *PrepareTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrepareTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareTxRequest proto.InternalMessageInfo

func (m *PrepareTxRequest) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *PrepareTxRequest) GetSignerAddress() string {
	if m != nil {
		return m.SignerAddress
	}
	return ""
}

func (m *PrepareTxRequest) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *PrepareTxRequest) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *PrepareTxRequest) GetTimeoutHeight() uint64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

func (m *PrepareTxRequest) GetFee() *CosmosTxFee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *PrepareTxRequest) GetMsgs() [][]byte {
	if m != nil {
		return m.Msgs
	}
	return nil
}

type CosmosTxFee struct {
	// Transaction gas price
	Price []*CosmosCoin `protobuf:"bytes,1,rep,name=price,proto3" json:"price,omitempty"`
	// Transaction gas limit
	Gas uint64 `protobuf:"varint,2,opt,name=gas,proto3" json:"gas,omitempty"`
	// Explicitly require fee delegation when set to true. Or don't care = false.
	// Will be replaced by other flag in the next version.
	DelegateFee bool `protobuf:"varint,3,opt,name=delegate_fee,json=delegateFee,proto3" json:"delegate_fee,omitempty"`
}

func (m *CosmosTxFee) Reset()         { *m = CosmosTxFee{} }
func (m *CosmosTxFee) String() string { return proto.CompactTextString(m) }
func (*CosmosTxFee) ProtoMessage()    {}
func (*CosmosTxFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{3}
}
func (m *CosmosTxFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosTxFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosTxFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosTxFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosTxFee.Merge(m, src)
}
func (m *CosmosTxFee) XXX_Size() int {
	return m.Size()
}
func (m *CosmosTxFee) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosTxFee.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosTxFee proto.InternalMessageInfo

func (m *CosmosTxFee) GetPrice() []*CosmosCoin {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *CosmosTxFee) GetGas() uint64 {
	if m != nil {
		return m.Gas
	}
	return 0
}

func (m *CosmosTxFee) GetDelegateFee() bool {
	if m != nil {
		return m.DelegateFee
	}
	return false
}

type CosmosCoin struct {
	// Coin denominator
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// Coin amount (big int)
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *CosmosCoin) Reset()         { *m = CosmosCoin{} }
func (m *CosmosCoin) String() string { return proto.CompactTextString(m) }
func (*CosmosCoin) ProtoMessage()    {}
func (*CosmosCoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{4}
}
func (m *CosmosCoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoin.Merge(m, src)
}
func (m *CosmosCoin) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoin) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoin.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoin proto.InternalMessageInfo

func (m *CosmosCoin) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoin) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type PrepareTxResponse struct {
	// EIP712-compatible message suitable for signing with eth_signTypedData_v4
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// Account tx sequence (nonce)
	Sequence uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Sign mode for the resulting tx
	SignMode string `protobuf:"bytes,3,opt,name=sign_mode,json=signMode,proto3" json:"sign_mode,omitempty"`
	// Specify proto-URL of a public key, which defines the signature format
	PubKeyType string `protobuf:"bytes,4,opt,name=pub_key_type,json=pubKeyType,proto3" json:"pub_key_type,omitempty"`
	// Fee payer address provided by service
	FeePayer string `protobuf:"bytes,5,opt,name=fee_payer,json=feePayer,proto3" json:"fee_payer,omitempty"`
	// Hex-encoded ethsecp256k1 signature bytes from fee payer
	FeePayerSig string `protobuf:"bytes,6,opt,name=fee_payer_sig,json=feePayerSig,proto3" json:"fee_payer_sig,omitempty"`
}

func (m *PrepareTxResponse) Reset()         { *m = PrepareTxResponse{} }
func (m *PrepareTxResponse) String() string { return proto.CompactTextString(m) }
func (*PrepareTxResponse) ProtoMessage()    {}
func (*PrepareTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{5}
}
func (m *PrepareTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareTxResponse.Merge(m, src)
}
func (m *PrepareTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *PrepareTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareTxResponse proto.InternalMessageInfo

func (m *PrepareTxResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *PrepareTxResponse) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *PrepareTxResponse) GetSignMode() string {
	if m != nil {
		return m.SignMode
	}
	return ""
}

func (m *PrepareTxResponse) GetPubKeyType() string {
	if m != nil {
		return m.PubKeyType
	}
	return ""
}

func (m *PrepareTxResponse) GetFeePayer() string {
	if m != nil {
		return m.FeePayer
	}
	return ""
}

func (m *PrepareTxResponse) GetFeePayerSig() string {
	if m != nil {
		return m.FeePayerSig
	}
	return ""
}

type BroadcastTxRequest struct {
	// Specify Web3 chainID (from prepateTx) for the target Tx
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Amino-encoded Tx JSON data (except Msgs)
	Tx []byte `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx,omitempty"`
	// List of Cosmos proto3-encoded Msgs from tx
	Msgs [][]byte `protobuf:"bytes,3,rep,name=msgs,proto3" json:"msgs,omitempty"`
	// Specify ethsecp256k1 pubkey of the signer
	PubKey *CosmosPubKey `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// Hex-encoded ethsecp256k1 signature bytes
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// Fee payer address provided by service
	FeePayer string `protobuf:"bytes,6,opt,name=fee_payer,json=feePayer,proto3" json:"fee_payer,omitempty"`
	// Hex-encoded ethsecp256k1 signature bytes from fee payer
	FeePayerSig string `protobuf:"bytes,7,opt,name=fee_payer_sig,json=feePayerSig,proto3" json:"fee_payer_sig,omitempty"`
	// Broadcast mode
	Mode string `protobuf:"bytes,8,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *BroadcastTxRequest) Reset()         { *m = BroadcastTxRequest{} }
func (m *BroadcastTxRequest) String() string { return proto.CompactTextString(m) }
func (*BroadcastTxRequest) ProtoMessage()    {}
func (*BroadcastTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{6}
}
func (m *BroadcastTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastTxRequest.Merge(m, src)
}
func (m *BroadcastTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastTxRequest proto.InternalMessageInfo

func (m *BroadcastTxRequest) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BroadcastTxRequest) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *BroadcastTxRequest) GetMsgs() [][]byte {
	if m != nil {
		return m.Msgs
	}
	return nil
}

func (m *BroadcastTxRequest) GetPubKey() *CosmosPubKey {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *BroadcastTxRequest) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *BroadcastTxRequest) GetFeePayer() string {
	if m != nil {
		return m.FeePayer
	}
	return ""
}

func (m *BroadcastTxRequest) GetFeePayerSig() string {
	if m != nil {
		return m.FeePayerSig
	}
	return ""
}

func (m *BroadcastTxRequest) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

type CosmosPubKey struct {
	// Pubkey type URL
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Hex-encoded string of the public key
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *CosmosPubKey) Reset()         { *m = CosmosPubKey{} }
func (m *CosmosPubKey) String() string { return proto.CompactTextString(m) }
func (*CosmosPubKey) ProtoMessage()    {}
func (*CosmosPubKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{7}
}
func (m *CosmosPubKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosPubKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosPubKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosPubKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosPubKey.Merge(m, src)
}
func (m *CosmosPubKey) XXX_Size() int {
	return m.Size()
}
func (m *CosmosPubKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosPubKey.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosPubKey proto.InternalMessageInfo

func (m *CosmosPubKey) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CosmosPubKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type BroadcastTxResponse struct {
	// Hex-encoded Tendermint transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// The block height
	Height int64 `protobuf:"zigzag64,2,opt,name=height,proto3" json:"height,omitempty"`
	// Tx index in the block
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	// Namespace for the resp code
	Codespace string `protobuf:"bytes,4,opt,name=codespace,proto3" json:"codespace,omitempty"`
	// Response code
	Code uint32 `protobuf:"varint,5,opt,name=code,proto3" json:"code,omitempty"`
	// Result bytes, if any
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// The output of the application's logger (raw string). May be
	// non-deterministic.
	RawLog string `protobuf:"bytes,7,opt,name=raw_log,json=rawLog,proto3" json:"raw_log,omitempty"`
	// Time of the previous block.
	Timestamp string `protobuf:"bytes,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *BroadcastTxResponse) Reset()         { *m = BroadcastTxResponse{} }
func (m *BroadcastTxResponse) String() string { return proto.CompactTextString(m) }
func (*BroadcastTxResponse) ProtoMessage()    {}
func (*BroadcastTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8125bca7913e1747, []int{8}
}
func (m *BroadcastTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastTxResponse.Merge(m, src)
}
func (m *BroadcastTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastTxResponse proto.InternalMessageInfo

func (m *BroadcastTxResponse) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *BroadcastTxResponse) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BroadcastTxResponse) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BroadcastTxResponse) GetCodespace() string {
	if m != nil {
		return m.Codespace
	}
	return ""
}

func (m *BroadcastTxResponse) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *BroadcastTxResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BroadcastTxResponse) GetRawLog() string {
	if m != nil {
		return m.RawLog
	}
	return ""
}

func (m *BroadcastTxResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func init() {
	proto.RegisterType((*GetTxRequest)(nil), "types.GetTxRequest")
	proto.RegisterType((*GetTxResponse)(nil), "types.GetTxResponse")
	proto.RegisterType((*PrepareTxRequest)(nil), "types.PrepareTxRequest")
	proto.RegisterType((*CosmosTxFee)(nil), "types.CosmosTxFee")
	proto.RegisterType((*CosmosCoin)(nil), "types.CosmosCoin")
	proto.RegisterType((*PrepareTxResponse)(nil), "types.PrepareTxResponse")
	proto.RegisterType((*BroadcastTxRequest)(nil), "types.BroadcastTxRequest")
	proto.RegisterType((*CosmosPubKey)(nil), "types.CosmosPubKey")
	proto.RegisterType((*BroadcastTxResponse)(nil), "types.BroadcastTxResponse")
}

func init() { proto.RegisterFile("types/tx_service.proto", fileDescriptor_8125bca7913e1747) }

var fileDescriptor_8125bca7913e1747 = []byte{
	// 887 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x55, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x5f, 0xe7, 0x7f, 0x26, 0x49, 0xd5, 0x4e, 0x57, 0xad, 0x1b, 0x96, 0x28, 0xf5, 0x82, 0x1a,
	0x2a, 0xba, 0x56, 0x17, 0x4e, 0xbd, 0xd1, 0x4a, 0x6d, 0x11, 0x20, 0xad, 0x86, 0x95, 0x90, 0xb8,
	0x58, 0x13, 0xfb, 0xad, 0x63, 0x35, 0xf6, 0xb8, 0x9e, 0x71, 0xeb, 0x5c, 0xf9, 0x04, 0x48, 0x7c,
	0x21, 0x24, 0x2e, 0x1c, 0x2b, 0xf5, 0x02, 0x37, 0xb4, 0x0b, 0xdf, 0x80, 0x0f, 0x80, 0xe6, 0xcd,
	0x24, 0x71, 0x76, 0x57, 0x82, 0x33, 0xb7, 0xf7, 0xff, 0xbd, 0xdf, 0xfb, 0x3d, 0x8f, 0xc9, 0x1d,
	0xb5, 0xca, 0x41, 0xfa, 0xaa, 0x0a, 0x24, 0x14, 0x6f, 0x92, 0x10, 0x8e, 0xf2, 0x42, 0x28, 0x41,
	0xdb, 0x68, 0x1f, 0x1f, 0xc4, 0x42, 0xc4, 0x4b, 0xf0, 0x79, 0x9e, 0xf8, 0x3c, 0xcb, 0x84, 0xe2,
	0x2a, 0x11, 0x99, 0x34, 0x41, 0xe3, 0xc3, 0x50, 0xc8, 0x54, 0x48, 0x7f, 0xce, 0x25, 0xf8, 0x7c,
	0x1e, 0x26, 0xfe, 0x9b, 0xc7, 0x73, 0x50, 0xfc, 0x31, 0x2a, 0x36, 0x68, 0x6c, 0x83, 0x54, 0xb5,
	0xf1, 0xaa, 0xca, 0xfa, 0xf6, 0x63, 0x11, 0x0b, 0x14, 0x7d, 0x2d, 0x59, 0xeb, 0xc3, 0x7a, 0xd9,
	0xd7, 0x25, 0x14, 0xab, 0x4d, 0x66, 0xce, 0xe3, 0x24, 0xc3, 0x19, 0x4c, 0xac, 0xe7, 0x91, 0xe1,
	0x0b, 0x50, 0xa7, 0x15, 0x83, 0xd7, 0x25, 0x48, 0x45, 0x29, 0x69, 0x2d, 0xb8, 0x5c, 0xb8, 0xce,
	0xd4, 0x99, 0xf5, 0x19, 0xca, 0xde, 0x7b, 0x87, 0x8c, 0x6c, 0x90, 0xcc, 0x45, 0x26, 0x81, 0xde,
	0x25, 0x5d, 0x55, 0x05, 0xb5, 0xc0, 0x8e, 0xaa, 0x5e, 0x72, 0xb9, 0xa0, 0x77, 0x48, 0x67, 0x01,
	0x49, 0xbc, 0x50, 0x6e, 0x63, 0xea, 0xcc, 0x28, 0xb3, 0x1a, 0xdd, 0x27, 0xed, 0x24, 0x8b, 0xa0,
	0x72, 0x9b, 0x53, 0x67, 0x36, 0x62, 0x46, 0xa1, 0x07, 0xa4, 0x1f, 0x8a, 0x08, 0x64, 0xce, 0x43,
	0x70, 0x5b, 0x58, 0x68, 0x6b, 0xd0, 0xa3, 0x68, 0xc5, 0x6d, 0x63, 0x0a, 0xca, 0xda, 0x16, 0x71,
	0xc5, 0xdd, 0xce, 0xd4, 0x99, 0x0d, 0x19, 0xca, 0x7a, 0x98, 0x82, 0xbf, 0x0d, 0x96, 0x22, 0x76,
	0xbb, 0x66, 0x98, 0x82, 0xbf, 0xfd, 0x5a, 0xc4, 0xba, 0xbc, 0x4a, 0x52, 0x90, 0x8a, 0xa7, 0xb9,
	0xdb, 0x33, 0xe5, 0x37, 0x06, 0xef, 0x2f, 0x87, 0xdc, 0x3c, 0x29, 0x20, 0xe7, 0x05, 0x6c, 0xe1,
	0xdf, 0x23, 0xbd, 0x70, 0xc1, 0x93, 0x2c, 0x48, 0x22, 0x44, 0xd6, 0x62, 0x5d, 0xd4, 0xbf, 0x8c,
	0xe8, 0xc7, 0xe4, 0x86, 0x4c, 0xe2, 0x0c, 0x8a, 0x80, 0x47, 0x51, 0x01, 0x52, 0x22, 0xc4, 0x3e,
	0x1b, 0x19, 0xeb, 0x17, 0xc6, 0x48, 0xc7, 0xa4, 0x27, 0x75, 0xb1, 0x2c, 0x04, 0x04, 0xdb, 0x62,
	0x1b, 0x5d, 0x4f, 0x9f, 0x42, 0x2a, 0x2c, 0x54, 0x94, 0x75, 0x59, 0x3d, 0x93, 0x28, 0x55, 0x60,
	0x37, 0xd7, 0xc6, 0xac, 0x91, 0xb5, 0xbe, 0x34, 0x0b, 0xfc, 0x88, 0x34, 0xcf, 0x00, 0x10, 0xf7,
	0xe0, 0x98, 0x1e, 0xe1, 0x75, 0x1d, 0x3d, 0x43, 0x9e, 0x4f, 0xab, 0xe7, 0x00, 0x4c, 0xbb, 0xb1,
	0x81, 0x8c, 0xa5, 0xdb, 0x9d, 0x36, 0xf5, 0x7a, 0xb4, 0xec, 0xbd, 0x22, 0x83, 0x5a, 0x1c, 0x7d,
	0x40, 0xda, 0x79, 0x91, 0x84, 0xe0, 0x3a, 0xd3, 0xe6, 0x6c, 0x70, 0x7c, 0x6b, 0xa7, 0xd4, 0x33,
	0x91, 0x64, 0xcc, 0xf8, 0xe9, 0x4d, 0xd2, 0x8c, 0xb9, 0x01, 0xd9, 0x62, 0x5a, 0xa4, 0xf7, 0xc9,
	0x30, 0x82, 0x25, 0xc4, 0x5c, 0x41, 0xa0, 0x87, 0xd1, 0xf0, 0x7a, 0x6c, 0xb0, 0xb6, 0x3d, 0x07,
	0xf0, 0x9e, 0x10, 0xb2, 0xad, 0xa4, 0x59, 0x8f, 0x20, 0x13, 0xa9, 0x3d, 0x12, 0xa3, 0xe8, 0x1b,
	0xe1, 0xa9, 0x28, 0x33, 0x65, 0x17, 0x68, 0x35, 0xef, 0x17, 0x87, 0xdc, 0xaa, 0x11, 0x62, 0x4f,
	0x6d, 0xcd, 0xb8, 0x3d, 0x48, 0x64, 0xbc, 0xbe, 0xe3, 0xc6, 0xa5, 0x1d, 0x7f, 0x40, 0xfa, 0x9a,
	0x90, 0x20, 0xd5, 0xa7, 0xd3, 0xc4, 0xa4, 0x9e, 0x36, 0x7c, 0xa3, 0xcf, 0x67, 0x4a, 0x86, 0x79,
	0x39, 0x0f, 0x5e, 0xc1, 0x2a, 0xd0, 0xb0, 0x2d, 0x11, 0x24, 0x2f, 0xe7, 0x5f, 0xc1, 0xea, 0x74,
	0x95, 0x63, 0xfa, 0x19, 0x40, 0x90, 0xf3, 0x15, 0x14, 0xc8, 0x44, 0x9f, 0xf5, 0xce, 0x00, 0x4e,
	0xb4, 0x4e, 0x3d, 0x32, 0xda, 0x38, 0x03, 0x99, 0xc4, 0x48, 0x47, 0x9f, 0x0d, 0xd6, 0x01, 0xdf,
	0x26, 0xb1, 0xf7, 0xb7, 0x43, 0xe8, 0xd3, 0x42, 0xf0, 0x28, 0xe4, 0x52, 0xfd, 0xa7, 0xc3, 0xba,
	0x41, 0x1a, 0xaa, 0x42, 0x1c, 0x43, 0xd6, 0x50, 0xd5, 0x86, 0xc4, 0xe6, 0x96, 0x44, 0xfa, 0x29,
	0xe9, 0xda, 0xc1, 0x71, 0xe6, 0xc1, 0xf1, 0xed, 0x1d, 0xde, 0x4e, 0x10, 0x00, 0xeb, 0x18, 0x20,
	0xfa, 0xf0, 0x35, 0x64, 0xae, 0xca, 0x02, 0x2c, 0x88, 0xad, 0x61, 0x17, 0x62, 0xe7, 0xdf, 0x20,
	0x76, 0xaf, 0x40, 0xc4, 0x01, 0xf5, 0x76, 0x7b, 0xf6, 0x8c, 0x45, 0x04, 0xde, 0xe7, 0x64, 0x58,
	0x1f, 0x45, 0xc7, 0xe0, 0x86, 0x2d, 0x6d, 0x5a, 0xd6, 0x17, 0xa5, 0x01, 0x18, 0xd6, 0xb5, 0xe8,
	0xfd, 0xee, 0x90, 0xdb, 0x3b, 0xcb, 0xfa, 0xff, 0xbc, 0x2f, 0xc7, 0x3f, 0x37, 0xc8, 0x80, 0x89,
	0x52, 0x41, 0x71, 0x5a, 0xb1, 0x3c, 0xa4, 0xdf, 0x91, 0x36, 0x3e, 0xa2, 0x74, 0x4d, 0x5d, 0xfd,
	0xdd, 0x1d, 0xef, 0xef, 0x1a, 0xcd, 0x1e, 0xbc, 0xc3, 0x1f, 0xde, 0xff, 0xf9, 0x53, 0xe3, 0xc3,
	0x27, 0xce, 0x43, 0xcf, 0xf5, 0x4d, 0x40, 0xad, 0xa4, 0x6f, 0xea, 0xc5, 0xa4, 0xbf, 0xf9, 0x6c,
	0xe8, 0x5d, 0x5b, 0xe7, 0xf2, 0xcb, 0x36, 0x76, 0xaf, 0x3a, 0x6c, 0x93, 0x07, 0xd8, 0xe4, 0xbe,
	0x6e, 0x72, 0x70, 0x4d, 0x93, 0x6d, 0x6d, 0x41, 0x06, 0x35, 0xb2, 0xe8, 0x3d, 0x5b, 0xf1, 0xea,
	0xb5, 0x8f, 0xc7, 0xd7, 0xb9, 0x6c, 0xbb, 0x4f, 0xb0, 0xdd, 0xa1, 0x6e, 0x37, 0xb9, 0xa6, 0x5d,
	0x2d, 0xe5, 0xe9, 0x8b, 0x5f, 0xcf, 0x27, 0xce, 0xbb, 0xf3, 0x89, 0xf3, 0xc7, 0xf9, 0xc4, 0xf9,
	0xf1, 0x62, 0xb2, 0xf7, 0xee, 0x62, 0xb2, 0xf7, 0xdb, 0xc5, 0x64, 0xef, 0xfb, 0x47, 0x71, 0xa2,
	0x16, 0xe5, 0xfc, 0x28, 0x14, 0xa9, 0x5f, 0x60, 0xf6, 0x23, 0xfc, 0x9f, 0x85, 0x62, 0xb9, 0xd6,
	0xf1, 0xf3, 0x32, 0x0d, 0xe6, 0x1d, 0x74, 0x7e, 0xf6, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x50,
	0x8a, 0x5f, 0x60, 0xae, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RouterTxRpcClient is the client API for RouterTxRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterTxRpcClient interface {
	// GetTx gets transaction details by hash.
	GetTx(ctx context.Context, in *GetTxRequest, opts ...grpc.CallOption) (*GetTxResponse, error)
	// PrepareTx generates a Web3-signable body for a Cosmos transaction
	PrepareTx(ctx context.Context, in *PrepareTxRequest, opts ...grpc.CallOption) (*PrepareTxResponse, error)
	// BroadcastTx broadcasts a signed Web3 transaction
	BroadcastTx(ctx context.Context, in *BroadcastTxRequest, opts ...grpc.CallOption) (*BroadcastTxResponse, error)
}

type routerTxRpcClient struct {
	cc grpc1.ClientConn
}

func NewRouterTxRpcClient(cc grpc1.ClientConn) RouterTxRpcClient {
	return &routerTxRpcClient{cc}
}

func (c *routerTxRpcClient) GetTx(ctx context.Context, in *GetTxRequest, opts ...grpc.CallOption) (*GetTxResponse, error) {
	out := new(GetTxResponse)
	err := c.cc.Invoke(ctx, "/types.RouterTxRpc/GetTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerTxRpcClient) PrepareTx(ctx context.Context, in *PrepareTxRequest, opts ...grpc.CallOption) (*PrepareTxResponse, error) {
	out := new(PrepareTxResponse)
	err := c.cc.Invoke(ctx, "/types.RouterTxRpc/PrepareTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerTxRpcClient) BroadcastTx(ctx context.Context, in *BroadcastTxRequest, opts ...grpc.CallOption) (*BroadcastTxResponse, error) {
	out := new(BroadcastTxResponse)
	err := c.cc.Invoke(ctx, "/types.RouterTxRpc/BroadcastTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterTxRpcServer is the server API for RouterTxRpc service.
type RouterTxRpcServer interface {
	// GetTx gets transaction details by hash.
	GetTx(context.Context, *GetTxRequest) (*GetTxResponse, error)
	// PrepareTx generates a Web3-signable body for a Cosmos transaction
	PrepareTx(context.Context, *PrepareTxRequest) (*PrepareTxResponse, error)
	// BroadcastTx broadcasts a signed Web3 transaction
	BroadcastTx(context.Context, *BroadcastTxRequest) (*BroadcastTxResponse, error)
}

// UnimplementedRouterTxRpcServer can be embedded to have forward compatible implementations.
type UnimplementedRouterTxRpcServer struct {
}

func (*UnimplementedRouterTxRpcServer) GetTx(ctx context.Context, req *GetTxRequest) (*GetTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTx not implemented")
}
func (*UnimplementedRouterTxRpcServer) PrepareTx(ctx context.Context, req *PrepareTxRequest) (*PrepareTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareTx not implemented")
}
func (*UnimplementedRouterTxRpcServer) BroadcastTx(ctx context.Context, req *BroadcastTxRequest) (*BroadcastTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTx not implemented")
}

func RegisterRouterTxRpcServer(s grpc1.Server, srv RouterTxRpcServer) {
	s.RegisterService(&_RouterTxRpc_serviceDesc, srv)
}

func _RouterTxRpc_GetTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterTxRpcServer).GetTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.RouterTxRpc/GetTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterTxRpcServer).GetTx(ctx, req.(*GetTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterTxRpc_PrepareTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterTxRpcServer).PrepareTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.RouterTxRpc/PrepareTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterTxRpcServer).PrepareTx(ctx, req.(*PrepareTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterTxRpc_BroadcastTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterTxRpcServer).BroadcastTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.RouterTxRpc/BroadcastTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterTxRpcServer).BroadcastTx(ctx, req.(*BroadcastTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouterTxRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.RouterTxRpc",
	HandlerType: (*RouterTxRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTx",
			Handler:    _RouterTxRpc_GetTx_Handler,
		},
		{
			MethodName: "PrepareTx",
			Handler:    _RouterTxRpc_PrepareTx_Handler,
		},
		{
			MethodName: "BroadcastTx",
			Handler:    _RouterTxRpc_BroadcastTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "types/tx_service.proto",
}

func (m *GetTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RawLog) > 0 {
		i -= len(m.RawLog)
		copy(dAtA[i:], m.RawLog)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.RawLog)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if m.Code != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Codespace) > 0 {
		i -= len(m.Codespace)
		copy(dAtA[i:], m.Codespace)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Codespace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Index != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTxService(dAtA, i, uint64((uint64(m.Height)<<1)^uint64((m.Height>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepareTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Msgs[iNdEx])
			copy(dAtA[i:], m.Msgs[iNdEx])
			i = encodeVarintTxService(dAtA, i, uint64(len(m.Msgs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TimeoutHeight != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Sequence != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SignerAddress) > 0 {
		i -= len(m.SignerAddress)
		copy(dAtA[i:], m.SignerAddress)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.SignerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CosmosTxFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosTxFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosTxFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegateFee {
		i--
		if m.DelegateFee {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Gas != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Gas))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Price[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTxService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CosmosCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepareTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeePayerSig) > 0 {
		i -= len(m.FeePayerSig)
		copy(dAtA[i:], m.FeePayerSig)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.FeePayerSig)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeePayer) > 0 {
		i -= len(m.FeePayer)
		copy(dAtA[i:], m.FeePayer)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.FeePayer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PubKeyType) > 0 {
		i -= len(m.PubKeyType)
		copy(dAtA[i:], m.PubKeyType)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.PubKeyType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SignMode) > 0 {
		i -= len(m.SignMode)
		copy(dAtA[i:], m.SignMode)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.SignMode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Sequence != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastTxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastTxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.FeePayerSig) > 0 {
		i -= len(m.FeePayerSig)
		copy(dAtA[i:], m.FeePayerSig)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.FeePayerSig)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FeePayer) > 0 {
		i -= len(m.FeePayer)
		copy(dAtA[i:], m.FeePayer)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.FeePayer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PubKey != nil {
		{
			size, err := m.PubKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Msgs[iNdEx])
			copy(dAtA[i:], m.Msgs[iNdEx])
			i = encodeVarintTxService(dAtA, i, uint64(len(m.Msgs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CosmosPubKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosPubKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosPubKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastTxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastTxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RawLog) > 0 {
		i -= len(m.RawLog)
		copy(dAtA[i:], m.RawLog)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.RawLog)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if m.Code != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Codespace) > 0 {
		i -= len(m.Codespace)
		copy(dAtA[i:], m.Codespace)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.Codespace)))
		i--
		dAtA[i] = 0x22
	}
	if m.Index != 0 {
		i = encodeVarintTxService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTxService(dAtA, i, uint64((uint64(m.Height)<<1)^uint64((m.Height>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTxService(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTxService(dAtA []byte, offset int, v uint64) int {
	offset -= sovTxService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *GetTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sozTxService(uint64(m.Height))
	}
	if m.Index != 0 {
		n += 1 + sovTxService(uint64(m.Index))
	}
	l = len(m.Codespace)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTxService(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.RawLog)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *PrepareTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovTxService(uint64(m.ChainId))
	}
	l = len(m.SignerAddress)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovTxService(uint64(m.Sequence))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovTxService(uint64(m.TimeoutHeight))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTxService(uint64(l))
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			l = len(b)
			n += 1 + l + sovTxService(uint64(l))
		}
	}
	return n
}

func (m *CosmosTxFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			l = e.Size()
			n += 1 + l + sovTxService(uint64(l))
		}
	}
	if m.Gas != 0 {
		n += 1 + sovTxService(uint64(m.Gas))
	}
	if m.DelegateFee {
		n += 2
	}
	return n
}

func (m *CosmosCoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *PrepareTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovTxService(uint64(m.Sequence))
	}
	l = len(m.SignMode)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.PubKeyType)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.FeePayer)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.FeePayerSig)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *BroadcastTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovTxService(uint64(m.ChainId))
	}
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			l = len(b)
			n += 1 + l + sovTxService(uint64(l))
		}
	}
	if m.PubKey != nil {
		l = m.PubKey.Size()
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.FeePayer)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.FeePayerSig)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *CosmosPubKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func (m *BroadcastTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sozTxService(uint64(m.Height))
	}
	if m.Index != 0 {
		n += 1 + sovTxService(uint64(m.Index))
	}
	l = len(m.Codespace)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTxService(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.RawLog)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovTxService(uint64(l))
	}
	return n
}

func sovTxService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTxService(x uint64) (n int) {
	return sovTxService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Height = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &CosmosTxFee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, make([]byte, postIndex-iNdEx))
			copy(m.Msgs[len(m.Msgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosTxFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosTxFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosTxFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = append(m.Price, &CosmosCoin{})
			if err := m.Price[len(m.Price)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			m.Gas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegateFee", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelegateFee = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeePayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeePayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeePayerSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeePayerSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, make([]byte, postIndex-iNdEx))
			copy(m.Msgs[len(m.Msgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKey == nil {
				m.PubKey = &CosmosPubKey{}
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeePayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeePayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeePayerSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeePayerSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosPubKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosPubKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosPubKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Height = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTxService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTxService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTxService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTxService = fmt.Errorf("proto: unexpected end of group")
)
